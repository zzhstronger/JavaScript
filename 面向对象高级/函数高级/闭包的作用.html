<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        //1.将函数作为另一个函数的返回值
        function fn1() {
            // 此时闭包已经产生了(fn2函数提升,内部函数已经创建了)
            var a = 1;
            function fn2() {
                a++;//引用外部函数的a
                console.log(a);
            }
            return fn2;//将函数fn2作为fn1函数的返回值返回
        }
        var f = fn1();//当外部函数调用n次就产生n个闭包，这里只调用一次，就产生了一个closure
        // 将fn1(),赋值给f,将闭包保存下来了,这一步非常关键
        //在反复执行内部函数时,闭包的数量不会增多，而且内部函数执行后不会消失,变量不会消失
        f();//2 该处若不使用闭包，则将在执行完第19行代码后，变量a会自动释放掉，此时a将不存在，执行fn2会报错
        f();//3
        fn1();//这里再次调用外部函数，则将再次产生一个内部函数对象，即将产生一个新的闭包closure
        f = null;//闭包死亡(包含闭包的函数成为垃圾对象)
    </script>
</head>

<body>
    <!-- 
        1.使用函数内部的变量在执行完以后，任然存活在内存中(延长了局部变量的生命周期)
        2.让函数外部可以操作(读写)到函数内部的数据(变量/函数)

        问题:
            1. 函数执行完后，函数内部声明的局部变量是否还存在?
                存在，原因，局部变量会保存在内部函数的closure对象当中，当外部函数执行完后，内部函数任然存在
            2. 在函数外部能直接访问到函数内部的局部变量吗?
                不能，但是能够通过closure闭包来间接访问到函数内部的局部变量
                通过内部函数引用外部函数的变量来将其保存在内部函数的closure闭包对象当中
                当将外部函数调用赋值给一个新的变量时(全局变量),将闭包保存到新的全局变量当中去
                此时全局作用能够访问到全局作用中的变量

        
        闭包的产生:在嵌套内部函数定义执行完时就产生了(不是在调用)
        闭包的死亡:在嵌套的内部函数成为垃圾对象时

    -->
</body>

</html>